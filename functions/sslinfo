# Part of zconfig · https://github.com/barabasz/zconfig · MIT License
#
# Inspect SSL/TLS certificates using openssl
# Use 'sslinfo --help' for more information.

local -A _fn=(
    [info]="Inspect SSL/TLS certificates using openssl"
    [desc]="Wrapper around openssl to inspect certificates from remote hosts or local files.
            Supports multiple display modes for different certificate information."
    [version]="0.9.5"
    [created]="2024-08-15"
    [modified]="2026-02-02"
    [license]="MIT"
    [author]="Andrzej Barabasz"
    [notes]="Requires openssl. Display modes are mutually exclusive (default: --most).
            Port defaults to 443 if not specified."
)

local -a _fn_args=(
    "host|Hostname with optional port (host or host:port)|o"
)

local -a _fn_opts=(
    "file|F|Use local certificate file|file"
    "all|a|Print full certificate output"
    "most|m|Print most info (skip modulus/exponent/hex)"
    "alt|A|Print Subject Alternative Names (SANs)"
    "common|c|Print Common Name"
    "issuer|i|Print Issuer"
    "subject|s|Print Subject"
    "dates|d|Print validity dates"
    "end|e|Print expiration date (not after)"
    "from|f|Print start date (not before)"
    "serial|S|Print serial number"
    "debug|D|Enable debug output"
)

local -a _fn_examples=(
    "sslinfo google.com|Show most info for google.com:443"
    "sslinfo example.com:8443|Show most info for custom port"
    "sslinfo -e google.com|Show expiration date"
    "sslinfo -A google.com|Show Subject Alternative Names"
    "sslinfo -F cert.pem|Inspect local certificate file"
    "sslinfo -a -F cert.pem|Full output from local file"
)

local -A opts=() args=()
_fn_init "$@" || return $REPLY

# Dependency check
(( ${+commands[openssl]} )) || { printe "openssl is required."; return 1 }

# Configuration
local host port="443"
local file="${opts[file]:-}"
local debug="${opts[debug]:-}"

# Logic: File vs Host
if [[ -n "$file" ]]; then
    [[ -f "$file" ]] || { printe "File not found: $file"; return 1 }
    [[ -n "$debug" ]] && print -u2 "DEBUG: Reading from file $file..."
elif [[ -n "${args[host]}" ]]; then
    local input="${args[host]}"
    if [[ "$input" == *:* ]]; then
        host="${input%:*}"
        port="${input##*:}"
    else
        host="$input"
    fi
    [[ -n "$debug" ]] && print -u2 "DEBUG: Target: $host, Port: $port"
else
    printe "Missing host or --file option."
    _fn_usage_short >&2
    return 1
fi

# Mode selection
local ossl_opts mode

if (( ${+opts[all]} )); then
    ossl_opts="-text"
    mode="all"
elif (( ${+opts[alt]} )); then
    ossl_opts="-text -certopt no_header,no_version,no_serial,no_signame,no_pubkey,no_sigdump,no_aux"
    mode="alt"
elif (( ${+opts[common]} )); then
    ossl_opts="-subject -nameopt multiline"
    mode="cn"
elif (( ${+opts[issuer]} )); then
    ossl_opts="-issuer -nameopt multiline"
    mode="issuer"
elif (( ${+opts[subject]} )); then
    ossl_opts="-subject -nameopt multiline"
    mode="subject"
elif (( ${+opts[dates]} )); then
    ossl_opts="-dates"
    mode="dates"
elif (( ${+opts[end]} )); then
    ossl_opts="-enddate"
    mode="end"
elif (( ${+opts[from]} )); then
    ossl_opts="-startdate"
    mode="from"
elif (( ${+opts[serial]} )); then
    ossl_opts="-serial"
    mode="serial"
else
    ossl_opts="-text -certopt no_header,no_version,no_serial,no_signame,no_pubkey,no_sigdump,no_aux"
    mode="most"
fi

[[ -n "$debug" ]] && print -u2 "DEBUG: Mode: $mode, Opts: $ossl_opts"

# Execution
local raw_output

if [[ -n "$host" ]]; then
    read -r -d '' raw_output < <(
        openssl s_client -connect "$host:$port" < /dev/null 2>/dev/null \
        | openssl x509 -noout $=ossl_opts
    )
else
    read -r -d '' raw_output < <(openssl x509 -in "$file" -noout $=ossl_opts)
fi

[[ -z "$raw_output" ]] && { printe "Failed to retrieve certificate info."; return 1 }

# Formatting
local -a lines
lines=("${(f)raw_output}")

case $mode in
    alt)
        local idx=$lines[(i)*Subject\ Alternative\ Name*]
        if (( idx <= ${#lines} )); then
            local san_line=$lines[idx+1]
            print -l "${(@)${(@s:,:)san_line}## #}"
        fi
        ;;
    cn)
        local cn_line=${(M)lines:#*commonName*}
        print -- "${cn_line##*= }"
        ;;
    end)
        local end_line=${(M)lines:#notAfter=*}
        print -- "${end_line#*=}"
        ;;
    from)
        local start_line=${(M)lines:#notBefore=*}
        print -- "${start_line#*=}"
        ;;
    serial)
        local serial_line=${(M)lines:#serial=*}
        print -- "${serial_line#*=}"
        ;;
    *)
        print -r -- $raw_output
        ;;
esac
