# Part of zconfig · https://github.com/barabasz/zconfig · MIT License
#
# Multi-DNS query tool - query multiple DNS servers and display results
# Use 'mdig --help' for more information.

local -A _fn=(
    [info]="Query multiple DNS servers and display results in a table"
    [desc]="Queries a domain against multiple DNS servers simultaneously and displays
            results sorted by response time with color-coded timing."
    [version]="0.5.1"
    [created]="2025"
    [modified]="2026-02-08"
    [license]="MIT"
    [author]="Andrzej Barabasz"
    [required]="dig"
    [notes]="Override default servers by setting MDIG_SERVERS associative array
            (e.g., MDIG_SERVERS=(Google 8.8.8.8 CloudFlare 1.1.1.1))."
)

local -a _fn_args=(
    "domain|Domain name to query|r|domain"
)

local -a _fn_examples=(
    "mdig example.com|Query example.com on all DNS servers"
    "mdig google.com|Query google.com on all DNS servers"
)

local -A opts=() args=()
_fn_init "$@" || return $REPLY

local domain=${args[domain]}

# DNS servers configuration (name=ip)
local -A dns_servers
if (( ${+MDIG_SERVERS} )); then
    dns_servers=( "${(@kv)MDIG_SERVERS}" )
else
    dns_servers=(
        CloudFlare  1.1.1.1
        Comodo      8.26.56.26
        DNS4EU      86.54.11.100
        Google      8.8.8.8
        NextDNS     45.90.28.141
        OpenDNS     208.67.222.222
        Orange      194.204.152.34
        Pi-hole     192.168.1.101
        Play        193.47.158.254
        Quad9       9.9.9.9
        Unbound     192.168.1.100
    )
fi

# Time thresholds for color coding (ms)
local -ri time_green=30
local -ri time_yellow=60

# Hide cursor for cleaner output
echotc vi 2>/dev/null

# Collect results with progress feedback
local name ip output time_ms answer
local -a results
local -i total=${#dns_servers}
local -i current=0

for name ip in ${(kv)dns_servers}; do
    (( current++ ))
    printf "\r\033[K${by}⏳${x} Querying ${b}%s${x} (%d/%d)..." "$name" "$current" "$total"

    output=$(dig @$ip $domain +noall +answer +stats +time=2 +tries=1 2>/dev/null)

    # Extract query time using zsh pattern matching
    if [[ $output =~ 'Query time: ([0-9]+)' ]]; then
        time_ms=$match[1]
    else
        time_ms=9999
    fi

    # Extract first A record
    answer=${${(M)${(f)output}:#*[[:space:]]A[[:space:]]*}##*[[:space:]]}
    [[ -z $answer ]] && answer="(no A record)"

    # Store: "time_ms:name:ip:answer"
    results+=("${time_ms}:${name}:${ip}:${answer}")
done

# Clear progress line
printf "\r\033[K"

# Restore cursor
echotc ve 2>/dev/null

# Header
printf "${b}%-28s %-14s %s${x}\n" "DNS" "Time (ms)" "Answer"

# Sort numerically by time and print
local line tc sort_time
for line in ${(n)results}; do
    sort_time=${line%%:*}
    line=${line#*:}
    name=${line%%:*}
    line=${line#*:}
    ip=${line%%:*}
    answer=${line#*:}

    # Color based on response time
    if (( sort_time < time_green )); then
        tc=$g
    elif (( sort_time < time_yellow )); then
        tc=$y
    elif (( sort_time < 9999 )); then
        tc=$r
    else
        tc=$x
    fi

    # Display timeout as "--"
    [[ $sort_time == 9999 ]] && sort_time="--"

    # Build first column with manual padding (ANSI codes break printf width)
    local col1="$name (${c}$ip${x})"
    local -i visible_len=${#:-$name ($ip)}
    local -i pad_len=$((28 - visible_len))
    (( pad_len > 0 )) && col1+="${(l:pad_len:: :)}"

    printf "%s ${tc}%-14s${x} %s\n" "$col1" "$sort_time" "$answer"
done
